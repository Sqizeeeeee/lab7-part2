# Version Control System - Performance Analysis

## Описание проекта

Упрощенная система управления версиями (аналог Git), реализованная на C++. Проект включает тестирование производительности и визуализацию результатов.

## Структура проекта


version_control_system/
├── include/ # Заголовочные файлы
│ ├── constants.h # Константы системы
│ ├── object.h # Объекты VCS (Blob, Tree, Commit)
│ ├── storage.h # Система хранения объектов
│ └── index.h # Индекс (staging area)
├── src/ # Исходный код
│ ├── main.cpp # Основная программа
│ ├── object.cpp # Реализация объектов
│ ├── storage.cpp # Реализация хранилища
│ └── index.cpp # Реализация индекса
├── tests/ # Тесты производительности
│ └── performance_test.cpp
├── data/ # Результаты тестов и графики
├── analysis.py # Анализ и визуализация результатов
└── CMakeLists.txt # Конфигурация сборки

## Команды системы

```bash
# Инициализация репозитория
./build/myvcs init

# Добавление файлов в индекс
./build/myvcs add <filename>

# Создание коммита
./build/myvcs commit "message"

# Просмотр статуса
./build/myvcs status
```

# Графики производительности

## 1. Основные графики производительности (performance_plots.png)

### Левый график: Add Operation

Ось X: Количество файлов (10, 50, 100, 200, 500) \
Ось Y: Время выполнения (микросекунды) \
Тренд: Линейный рост времени с увеличением количества файлов \
Интерпретация: Операция add демонстрирует сложность O(n), где время пропорционально количеству файлов \
Ключевые точки: Каждая точка показывает время обработки определенного количества файлов \


### Правый график: Commit Operation

Ось X: Количество файлов
Ось Y: Время выполнения (микросекунды)
Тренд: Также линейная зависимость, но с другим углом наклона
Интерпретация: Commit операция имеет сложность O(n), но с большей константой из-за создания дополнительных объектов (Tree, Commit)

## 2. Комбинированный график (performance_combined.png)

Сравнение: Две линии на одном графике - синяя для Add, красная для Commit
Анализ: Позволяет визуально сравнить производительность двух операций
Вывод: Commit операция требует больше времени на один файл по сравнению с Add операцией


## 3. Регрессионный анализ (regression_analysis.png)

### Левый график: Add Operation Regression

Синие точки: Фактические измерения времени
Красная линия: Линейная регрессия, показывающая общий тренд
Полоса уверенности: Область вокруг линии показывает статистическую уверенность в предсказании

### Правый график: Commit Operation Regression

Аналогичная структура для commit операции
Наблюдение: Более крутой наклон линии указывает на большую временную сложность на один файл


# Анализ вычислительной сложности

## Теоретическая сложность

### Add Operation: O(n)

Чтение каждого файла: O(n)
Создание blob объектов: O(n)
Запись в индекс: O(n)
Итог: Линейная сложность O(n)

### Commit Operation: O(n)

Создание tree объекта: O(n)
Создание commit объекта: O(1)
Запись объектов: O(n)
Итог: Линейная сложность O(n)



# Практическое подтверждение

## Данные эксперимента подтверждают теоретические оценки:

Линейный рост времени выполнения для обеих операций
Постоянное отношение время/файл для каждого типа операции
Предсказуемое масштабирование с увеличением количества файлов
Методология тестирования

## Генерация тестовых данных

Файлы размером 1KB каждый
Различные наборы: 10, 50, 100, 200, 500 файлов
Случайное содержимое для избежания оптимизаций кеширования

## Измерения

Время в микросекундах
5 прогонов для каждого размера набора
Усреднение результатов
Измерение только времени выполнения, исключая время генерации файлов
Интерпретация результатов

### Производительность Add операции

Быстрая обработка отдельных файлов
Эффективное использование хеширования
Минимальные накладные расходы

### Производительность Commit операции

Большие накладные расходы из-за создания структур данных
Требует создания tree и commit объектов
Все еще линейная сложность, но с большей константой